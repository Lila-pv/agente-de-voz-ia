<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asistente de Voz Gemini - Simulación</title>
    <!-- Carga de Tailwind CSS para un diseño moderno y responsive -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Estilos personalizados para el tema oscuro y la animación de carga */
        body { font-family: 'Inter', sans-serif; background-color: #0d1117; color: #c9d1d9; }
        .card { background-color: #161b22; border: 1px solid #30363d; }
        .btn-primary { 
            background-color: #238636; 
            border-color: #238636; 
            transition: all 0.2s;
        }
        .btn-primary:hover:not(:disabled) { background-color: #2ea043; box-shadow: 0 4px 6px rgba(46, 160, 67, 0.2); }
        .btn-primary:disabled { 
            opacity: 0.6; 
            cursor: not-allowed; 
            background-color: #238636;
        }

        /* Animación de los puntos de carga */
        .loading-dot {
            animation: bounce 0.6s infinite alternate;
            background-color: #58a6ff;
            width: 8px; height: 8px; border-radius: 50%;
            margin: 0 4px;
        }
        .loading-dot:nth-child(2) { animation-delay: 0.2s; }
        .loading-dot:nth-child(3) { animation-delay: 0.4s; }
        @keyframes bounce {
            to { transform: translateY(-10px); }
        }
    </style>
    <script>
        // Configuración de colores de Tailwind
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary': '#58a6ff',
                        'success': '#238636',
                        'danger': '#f85149',
                        'background': '#0d1117',
                        'surface': '#161b22',
                    }
                }
            }
        }
    </script>
</head>
<body class="p-4 md:p-8 flex items-center justify-center min-h-screen">

    <div id="app" class="w-full max-w-lg">
        <div class="card p-6 rounded-xl shadow-2xl">
            <h1 class="text-2xl font-bold mb-4 text-primary text-center">Asistente de Voz Gemini</h1>

            <!-- Área de Entrada de Usuario -->
            <div class="flex flex-col gap-3 mb-6">
                <textarea id="userInput" class="w-full p-3 rounded-lg bg-surface border border-[#30363d] focus:border-primary focus:ring-1 focus:ring-primary transition resize-none h-24" placeholder="Haz tu pregunta (ej: '¿Qué es IP?')"></textarea>
                <button id="sendButton" class="btn-primary py-2 px-4 rounded-lg font-semibold shadow-md transition duration-200 flex items-center justify-center">
                    Enviar Consulta
                </button>
            </div>

            <!-- Área de Respuesta -->
            <div id="responseContainer" class="p-4 card rounded-lg min-h-[100px] flex flex-col justify-center">
                <p id="responseText" class="text-sm italic text-gray-400">La respuesta del Asistente aparecerá aquí.</p>
                <div id="loadingIndicator" class="hidden flex justify-center items-center py-4">
                    <div class="loading-dot"></div>
                    <div class="loading-dot"></div>
                    <div class="loading-dot"></div>
                </div>
            </div>

            <!-- Área de Debugging y Errores (Muestra el 403 si falla después de reintentos) -->
            <div id="debugArea" class="mt-4 p-3 bg-danger/20 border border-danger rounded-lg text-xs hidden">
                <h3 class="font-bold text-danger mb-1">Error del Sistema (403/429):</h3>
                <p id="errorMessage" class="text-danger"></p>
            </div>

        </div>
    </div>

    <script>
        // La clave de API se deja vacía; el entorno de Canvas la inyectará automáticamente en tiempo de ejecución.
        const API_KEY = ""; 
        const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent";
        const MAX_RETRIES = 5; // Número máximo de reintentos
        
        // Elementos del DOM
        const userInput = document.getElementById('userInput');
        const sendButton = document.getElementById('sendButton');
        const responseText = document.getElementById('responseText');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const debugArea = document.getElementById('debugArea');
        const errorMessage = document.getElementById('errorMessage');

        /**
         * Actualiza la interfaz de usuario con el estado actual (loading, ready, error).
         * @param {string} state - 'loading', 'ready', 'error', o 'initial'.
         * @param {string} content - Contenido de la respuesta o mensaje de error.
         */
        function updateUI(state, content = '') {
            sendButton.disabled = state === 'loading';
            sendButton.textContent = state === 'loading' ? 'Procesando...' : 'Enviar Consulta';
            loadingIndicator.classList.toggle('hidden', state !== 'loading');
            
            // Limpiar estilos y errores
            debugArea.classList.add('hidden');
            errorMessage.textContent = '';
            responseText.classList.remove('text-danger', 'text-sm', 'italic');
            responseText.classList.add('text-lg', 'text-white', 'font-normal');
            
            if (state === 'ready') {
                responseText.innerHTML = content;
            } else if (state === 'error') {
                debugArea.classList.remove('hidden');
                errorMessage.textContent = content;
                responseText.textContent = 'Lo siento, no pude procesar tu solicitud. Revisa el error detallado abajo.';
                responseText.classList.add('text-danger');
            } else if (state === 'initial') {
                responseText.textContent = 'La respuesta del Asistente aparecerá aquí.';
                responseText.classList.add('text-sm', 'italic');
                responseText.classList.remove('text-lg', 'text-white', 'font-normal');
            }
        }

        /**
         * Realiza la llamada a la API de Gemini con manejo de reintentos exponenciales.
         */
        async function handleQuery() {
            const userQuery = userInput.value.trim();
            if (!userQuery) {
                updateUI('error', 'Por favor, introduce una pregunta.');
                return;
            }

            updateUI('loading');

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                // Habilitamos Google Search para grounding (respuestas actuales)
                tools: [{ "google_search": {} }], 
                systemInstruction: {
                    parts: [{ text: "Actúa como un asistente de voz amigable y conciso, respondiendo en español. Prioriza la precisión y la información actual." }]
                },
            };
            
            const apiUrlWithKey = `${API_URL}?key=${API_KEY}`;

            let response = null;
            let lastError = null;

            // --- LÓGICA DE REINTENTO EXPONENCIAL (SOLUCIÓN AL ERROR 403/429) ---
            for (let i = 0; i < MAX_RETRIES; i++) {
                try {
                    // Esperar antes de cada reintento (a partir del segundo intento)
                    if (i > 0) {
                        const delay = Math.pow(2, i) * 1000; // Retraso: 2s, 4s, 8s, 16s...
                        await new Promise(resolve => setTimeout(resolve, delay));
                        console.log(`Reintento ${i + 1} después de ${delay / 1000}s...`);
                    }

                    const fetchResponse = await fetch(apiUrlWithKey, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    // Leemos el cuerpo de la respuesta, incluso si es un error HTTP
                    response = await fetchResponse.json();

                    // Si la respuesta es OK (200-299), el problema se ha resuelto. Salimos del bucle
                    if (fetchResponse.ok) {
                        break;
                    } 
                    
                    // Si es un error reintentable (403, 429), guardamos el error y continuamos el bucle
                    if (fetchResponse.status === 403 || fetchResponse.status === 429) {
                        lastError = `Error HTTP ${fetchResponse.status}. Mensaje: ${response.error?.message || 'Error desconocido de API. (Reintentando...)'}`;
                        console.error(`Error transitorio.`, lastError);
                    } else {
                        // Para cualquier otro error (ej: 400 Bad Request), es un error fatal. Lanzamos para salir.
                        lastError = `Error HTTP ${fetchResponse.status}. Mensaje: ${response.error?.message || 'Error desconocido de API. (Fallo fatal)'}`;
                        throw new Error(lastError); 
                    }

                } catch (error) {
                    // Esto atrapa errores de red o errores fatales lanzados internamente
                    lastError = `Fallo en la conexión o error fatal: ${error.message}`;
                    console.error('Error de red/fetch.', lastError);
                }

                if (i === MAX_RETRIES - 1) {
                    // Si hemos agotado los reintentos
                    updateUI('error', `Error Final después de ${MAX_RETRIES} intentos: ${lastError}`);
                    return;
                }
            }
            // --- FIN LÓGICA DE REINTENTO ---

            // 2. Procesamiento de la respuesta
            if (!response || !response.candidates || response.candidates.length === 0) {
                updateUI('error', 'Error: La API no devolvió una respuesta válida.');
                return;
            }

            const candidate = response.candidates[0];
            let generatedText = candidate.content?.parts?.[0]?.text || "No se pudo generar una respuesta.";
            
            // 3. Extracción de citaciones
            let sourcesHTML = '';
            const groundingMetadata = candidate.groundingMetadata;
            if (groundingMetadata && groundingMetadata.groundingAttributions) {
                const sources = groundingMetadata.groundingAttributions
                    .map(attr => ({
                        uri: attr.web?.uri,
                        title: attr.web?.title,
                    }))
                    .filter(source => source.uri && source.title);

                if (sources.length > 0) {
                    sourcesHTML = '<p class="text-xs text-gray-500 mt-2">Fuentes:</p>';
                    sources.forEach((source) => {
                        sourcesHTML += `<p class="text-xs text-gray-500 ml-2"> <a href="${source.uri}" target="_blank" class="hover:text-primary transition duration-150">${source.title}</a></p>`;
                    });
                }
            }

            // 4. Mostrar el resultado
            updateUI('ready', generatedText + sourcesHTML);
        }

        // Inicializar la UI y adjuntar eventos
        window.onload = () => {
            updateUI('initial');
            sendButton.addEventListener('click', handleQuery);
            userInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    handleQuery();
                }
            });
            // Valor de prueba
            userInput.value = "¿Qué es una dirección IP y para qué sirve?"; 
        };
    </script>
</body>
</html>