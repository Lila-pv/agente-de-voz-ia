<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agente de IA con Voz y Texto</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        #responseOutput {
            white-space: pre-wrap; 
            word-break: break-word;
        }
        .mic-listening {
            animation: pulse-mic 1s infinite;
        }
        @keyframes pulse-mic {
            0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen p-4 sm:p-8">
    <div class="max-w-3xl mx-auto bg-white p-6 rounded-xl shadow-2xl border border-gray-100">
        <!-- T铆tulo Principal -->
        <h1 class="text-3xl font-extrabold mb-2 text-indigo-700 flex items-center">
            <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-bot mr-3 text-emerald-500"><path d="M12 8V4H8"/><path d="M2 13V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v7a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2z"/><path d="M10 9h4"/><path d="M8 17h8"/><path d="M20 9H4"/></svg>
            Agente de IA con Voz y Texto
        </h1>
        <p class="text-sm text-gray-500 mb-6">Modelo: Gemini Flash (Texto) y Gemini TTS (Voz) v铆a Proxy Seguro.</p>
        
        <!-- rea de Input para el Prompt -->
        <div class="mb-6">
            <label for="prompt" class="block text-md font-semibold text-gray-700 mb-2">
                Consulta (Texto o Voz):
            </label>
            <textarea id="prompt" rows="4" 
                      class="mt-1 block w-full rounded-xl border border-gray-300 shadow-inner focus:border-indigo-600 focus:ring-indigo-600 p-4 text-gray-800 transition duration-150 resize-none" 
                      placeholder="Escribe aqu铆 o usa el bot贸n de Micr贸fono para grabar tu voz."></textarea>
        </div>

        <!-- Controles de Interacci贸n -->
        <div class="flex space-x-3 mb-8">
            <!-- Bot贸n 1: Enviar Texto -->
            <button id="textSendButton" 
                    class="flex-1 py-3 px-4 border border-transparent rounded-xl shadow-lg text-white font-bold bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-offset-2 focus:ring-indigo-500 transition duration-200 ease-in-out disabled:bg-indigo-400">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-send inline-block mr-2"><path d="m22 2-7 14-5-5-14-7z"/><path d="M22 2 11 13"/></svg>
                Enviar Texto
            </button>
            
            <!-- Bot贸n 2: Input de Voz (STT) -->
            <button id="micInputButton" 
                    class="flex-none py-3 px-4 rounded-xl shadow-lg text-white font-bold bg-red-500 hover:bg-red-600 focus:outline-none focus:ring-4 focus:ring-offset-2 focus:ring-red-400 transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-mic-vocal inline-block" id="micIcon"><path d="m12 11-1 9-2-5-5-2-9-1 9 1 5 2 2 5 1-9-1-9 1-9"/><path d="m12 11 1 9 2-5 5-2 9-1-9 1-5 2-2 5-1-9 1-9 1-9"/></svg>
            </button>

            <!-- Bot贸n 3: Output de Voz (TTS) -->
            <button id="ttsPlayButton" disabled
                    class="flex-none py-3 px-4 rounded-xl shadow-lg text-white font-bold bg-emerald-500 hover:bg-emerald-600 focus:outline-none focus:ring-4 focus:ring-offset-2 focus:ring-emerald-400 transition duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-volume-2 inline-block" id="volumeIcon"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/></svg>
                <span id="ttsButtonText">Reproducir Voz</span>
            </button>
        </div>

        <!-- Indicador de Carga -->
        <div id="loading" class="mt-4 hidden text-center text-indigo-600 font-bold text-lg p-2 rounded-lg bg-indigo-50 animate-pulse">
            <span id="loadingText" class="inline-block mr-2">...</span> Procesando solicitud...
        </div>

        <!-- rea de Output para la Respuesta -->
        <div class="mt-8">
            <h2 class="text-xl font-extrabold border-b-2 border-indigo-200 pb-2 mb-4 text-gray-800 flex justify-between items-center">
                Respuesta del Agente
                <span id="status" class="text-xs font-medium text-gray-400"></span>
            </h2>
            <div id="responseOutput" class="p-4 bg-gray-100 rounded-xl border border-gray-200 text-gray-800 text-sm min-h-[150px] leading-relaxed shadow-inner transition duration-300">
                Aqu铆 aparecer谩 el texto generado por la IA.
            </div>
        </div>
    </div>

    <script>
        const textSendButton = document.getElementById('textSendButton');
        const micInputButton = document.getElementById('micInputButton');
        const ttsPlayButton = document.getElementById('ttsPlayButton');
        const ttsButtonText = document.getElementById('ttsButtonText');
        const promptInput = document.getElementById('prompt');
        const responseOutput = document.getElementById('responseOutput');
        const loadingIndicator = document.getElementById('loading');
        const loadingText = document.getElementById('loadingText');
        const statusDisplay = document.getElementById('status');
        
        // Configuraci贸n de la API
        const PROXY_URL = '/api/gemini-proxy'; 
        
        // Estado de la aplicaci贸n
        let lastResponseText = '';
        let audioPlayer = null; 
        let isListening = false;
        
        // --- 1. SPEECH-TO-TEXT (STT) ---
        // Verificar y configurar la API de reconocimiento de voz
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition = null;

        if (SpeechRecognition) {
            recognition = new SpeechRecognition();
            recognition.continuous = false; // Detener la escucha tras la pausa
            recognition.lang = 'es-ES'; // Lenguaje: Espa帽ol
            recognition.interimResults = false; // Solo resultados finales
            
            recognition.onstart = () => {
                isListening = true;
                micInputButton.classList.add('mic-listening', 'bg-red-700');
                promptInput.placeholder = "隆Escuchando! Habla ahora...";
            };

            recognition.onresult = (event) => {
                const transcript = event.results[0][0].transcript;
                promptInput.value = transcript;
                promptInput.placeholder = "Texto reconocido. Procesando...";
                
                // Enviar el prompt autom谩ticamente
                fetchGeminiResponse(transcript); 
            };

            recognition.onend = () => {
                isListening = false;
                micInputButton.classList.remove('mic-listening', 'bg-red-700');
                promptInput.placeholder = "Escribe aqu铆 o usa el bot贸n de Micr贸fono para grabar tu voz.";

                // Solo si no estamos ya en proceso de respuesta
                if (statusDisplay.textContent !== 'Solicitud en curso...') {
                     micInputButton.disabled = false;
                }
            };
            
            recognition.onerror = (event) => {
                console.error('Error de reconocimiento de voz:', event.error);
                promptInput.value = `[Error de Voz: ${event.error}]`;
                micInputButton.disabled = false;
                isListening = false;
            };

        } else {
            micInputButton.disabled = true;
            micInputButton.title = "Tu navegador no soporta la API de Reconocimiento de Voz.";
            console.warn("La API de Reconocimiento de Voz no est谩 disponible en este navegador.");
        }

        function toggleMicInput() {
            if (isListening) {
                recognition.stop();
            } else if (recognition) {
                // Deshabilitar botones de env铆o mientras grabamos
                micInputButton.disabled = true;
                textSendButton.disabled = true;
                ttsPlayButton.disabled = true;

                recognition.start();
            }
        }
        
        // --- 2. TEXT GENERATION (Gemini Flash) ---
        
        async function fetchGeminiResponse(promptOverride = null) {
            const prompt = promptOverride || promptInput.value.trim();
            if (!prompt) {
                responseOutput.textContent = "Por favor, ingresa una pregunta o comando para comenzar.";
                return;
            }

            // Deshabilitar botones y mostrar carga
            loadingIndicator.classList.remove('hidden');
            loadingText.textContent = 'Pensando y buscando informaci贸n...';
            textSendButton.disabled = true;
            micInputButton.disabled = true;
            ttsPlayButton.disabled = true;
            responseOutput.textContent = 'Generando...';
            statusDisplay.textContent = 'Solicitud en curso...';
            lastResponseText = ''; 

            try {
                // Llamada al proxy para generaci贸n de texto (NO TTS)
                const response = await fetch(PROXY_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        prompt: prompt,
                        isTTS: false, // Indicador de que es una solicitud de texto
                        systemInstruction: "Act煤a como un Agente de IA amigable, profesional y conciso. Verifica los datos con las herramientas disponibles.",
                    })
                });

                const result = await response.json();

                if (!response.ok) {
                    statusDisplay.textContent = 'Error';
                    responseOutput.textContent = `[ERROR del Servidor Proxy]\nDetalles: ${JSON.stringify(result.details || result, null, 2)}`;
                    return;
                }

                // Procesar la respuesta exitosa
                statusDisplay.textContent = 'Completo';
                const candidate = result.candidates[0];
                let generatedText = candidate.content.parts[0].text;
                
                // Extraer y formatear fuentes
                let sourcesText = '';
                const groundingMetadata = candidate.groundingMetadata;
                if (groundingMetadata && groundingMetadata.groundingAttributions) {
                    sourcesText = '\n\n---\n Fuentes consultadas:\n';
                    groundingMetadata.groundingAttributions.forEach((attr, index) => {
                        if (attr.web && attr.web.uri) {
                            sourcesText += `[${index + 1}] ${attr.web.title || 'Enlace sin t铆tulo'}: ${attr.web.uri}\n`;
                        }
                    });
                }
                
                responseOutput.textContent = generatedText + sourcesText;
                
                // Almacenar SOLO el texto generado (sin fuentes) para TTS
                lastResponseText = generatedText.replace(/\n\n---[\s\S]*/, '');
                ttsPlayButton.disabled = false;

            } catch (error) {
                console.error('Error de conexi贸n en el cliente:', error);
                statusDisplay.textContent = 'Error de Conexi贸n';
                responseOutput.textContent = 'Ocurri贸 un error de red o de conexi贸n. Aseg煤rate de que el proxy est茅 funcionando.';
            } finally {
                // Restaurar la UI
                loadingIndicator.classList.add('hidden');
                textSendButton.disabled = false;
                micInputButton.disabled = false;
            }
        }
        
        // --- 3. TEXT-TO-SPEECH (TTS) Utilities ---

        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function pcmToWav(pcm16, sampleRate) {
            const numChannels = 1;
            const bitsPerSample = 16;
            const dataLength = pcm16.length * (bitsPerSample / 8); 
            const buffer = new ArrayBuffer(44 + dataLength);
            const view = new DataView(buffer);
            let offset = 0;

            const writeString = (str) => {
                for (let i = 0; i < str.length; i++) {
                    view.setUint8(offset + i, str.charCodeAt(i));
                }
                offset += str.length;
            };

            const writeUint32 = (value) => {
                view.setUint32(offset, value, true);
                offset += 4;
            };

            const writeUint16 = (value) => {
                view.setUint16(offset, value, true);
                offset += 2;
            };

            // RIFF chunk
            writeString('RIFF');
            writeUint32(36 + dataLength); 
            writeString('WAVE');

            // FMT chunk
            writeString('fmt ');
            writeUint32(16); 
            writeUint16(1);  
            writeUint16(numChannels);
            writeUint32(sampleRate);
            writeUint32(sampleRate * numChannels * (bitsPerSample / 8)); 
            writeUint16(numChannels * (bitsPerSample / 8)); 
            writeUint16(bitsPerSample);

            // DATA chunk
            writeString('data');
            writeUint32(dataLength); 

            // Escribir los datos PCM (Int16Array)
            const pcmView = new DataView(pcm16.buffer);
            for (let i = 0; i < pcm16.length; i++) {
                view.setInt16(offset, pcmView.getInt16(i * 2, true), true);
                offset += 2;
            }

            return new Blob([buffer], { type: 'audio/wav' });
        }

        function playAudio(wavBlob) {
            if (audioPlayer) {
                audioPlayer.pause();
                audioPlayer.currentTime = 0;
            }
            const audioUrl = URL.createObjectURL(wavBlob);
            audioPlayer = new Audio(audioUrl);
            
            // UI Feedback
            ttsPlayButton.disabled = true; // Deshabilitar durante la reproducci贸n
            ttsButtonText.textContent = 'Hablando...'; 
            
            audioPlayer.onplay = () => { /* Nada adicional */ };
            audioPlayer.onended = () => { 
                ttsButtonText.textContent = 'Reproducir Voz'; 
                ttsPlayButton.disabled = false; // Re-habilitar
                URL.revokeObjectURL(audioUrl);
            };
            audioPlayer.onerror = () => {
                ttsButtonText.textContent = 'Error Voz';
                console.error('Error al reproducir audio');
                ttsPlayButton.disabled = false; // Re-habilitar
                URL.revokeObjectURL(audioUrl);
            }
            
            audioPlayer.play();
        }


        // --- 4. TTS Request Handler ---

        async function handleTtsRequest() {
            if (!lastResponseText) {
                responseOutput.textContent += "\n\n[ERROR: Primero genera una respuesta de texto con el bot贸n de Enviar Texto o Micr贸fono.]";
                return;
            }
            
            // 1. Deshabilitar botones y mostrar carga
            ttsPlayButton.disabled = true;
            textSendButton.disabled = true;
            micInputButton.disabled = true;
            loadingIndicator.classList.remove('hidden');
            loadingText.textContent = 'Generando audio...';
            ttsButtonText.textContent = 'Cargando...';

            try {
                // Llamada al proxy para TTS
                const response = await fetch(PROXY_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        prompt: lastResponseText,
                        isTTS: true, // 隆CLAVE! El proxy debe reconocer esto.
                        voiceName: 'Kore' // Voz en Espa帽ol
                    })
                });

                const result = await response.json();

                if (!response.ok || !result.audioData || !result.mimeType) {
                    throw new Error(result.error || 'Respuesta de audio inv谩lida del proxy.');
                }
                
                // 2. Extracci贸n y Conversi贸n
                const audioData = result.audioData;
                const mimeType = result.mimeType; 

                const rateMatch = mimeType.match(/rate=(\d+)/);
                const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 24000; 

                const pcmData = base64ToArrayBuffer(audioData);
                const pcm16 = new Int16Array(pcmData);
                const wavBlob = pcmToWav(pcm16, sampleRate);
                
                // 3. Reproducci贸n
                playAudio(wavBlob);

            } catch (error) {
                console.error('Error en la generaci贸n/reproducci贸n de voz:', error);
                ttsButtonText.textContent = 'Error Voz';
                responseOutput.textContent += "\n\n[ERROR DE VOZ: No se pudo generar o reproducir el audio. Verifica la configuraci贸n de tu proxy TTS.]";
                ttsPlayButton.disabled = false;
            } finally {
                // 4. Restaurar UI
                loadingIndicator.classList.add('hidden');
                textSendButton.disabled = false;
                micInputButton.disabled = false;
            }
        }

        // --- Event Listeners ---
        textSendButton.addEventListener('click', () => fetchGeminiResponse());
        micInputButton.addEventListener('click', toggleMicInput);
        ttsPlayButton.addEventListener('click', handleTtsRequest);
        
        // Permite enviar con Enter
        promptInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                fetchGeminiResponse();
            }
        });
    </script>
</body>
</html>