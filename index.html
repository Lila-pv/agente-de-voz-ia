<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Agente de Voz IA Nativo</title>
    <!-- Incluimos Tailwind CSS para el estilizado -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      // ConfiguraciÃ³n de Tailwind para la fuente Inter
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              sans: ['Inter', 'sans-serif'],
            },
          }
        }
      }
    </script>
    <!-- Incluimos Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* Estilo simple para asegurar que el chat ocupa el espacio */
        #chat-container {
            max-height: 400px; /* Altura mÃ¡xima del historial */
        }
    </style>
</head>
<body class="bg-gray-50 antialiased min-h-screen">
    <div id="root" class="min-h-screen bg-gradient-to-br from-indigo-50 to-purple-100 flex flex-col p-4 sm:p-6 lg:p-8">
        <header class="mb-6 text-center">
            <h1 class="text-3xl font-extrabold text-indigo-700 flex items-center justify-center">
                <svg id="volume-icon" class="w-7 h-7 mr-2" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 5L6 9H2v6h4l5 4V5z"/><path d="M15.54 8.46a7 7 0 0 1 0 7.08"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/></svg>
                Agente de Voz IA
            </h1>
            <p class="text-gray-600 mt-1 flex items-center justify-center text-sm">
                <svg id="shield-icon" class="w-4 h-4 mr-1 text-indigo-500" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-12V5l-8-3-8 3v5c0 8 8 12 8 12z"/></svg>
                Agente con <strong>Guardrail</strong> de Seguridad y respuesta audible.
            </p>
        </header>
        
        <!-- Elemento oculto para la reproducciÃ³n de audio -->
        <audio id="audio-player" class="hidden"></audio>

        <!-- Contenedor Principal del Chat -->
        <div class="flex-grow flex flex-col bg-white rounded-2xl shadow-2xl overflow-hidden max-w-xl w-full mx-auto border border-indigo-200">
            
            <!-- Historial de Mensajes -->
            <div id="chat-container" class="flex-grow p-4 space-y-4 overflow-y-auto">
                <div class="text-center text-sm text-gray-500 p-2 bg-indigo-50 rounded-lg">
                    ðŸ‘‹ Â¡Hola! Soy el Agente de Voz IA. Pregunta sobre seguridad, pero ten en cuenta mi Guardrail.
                </div>
                <!-- Los mensajes se inyectarÃ¡n aquÃ­ -->
            </div>

            <!-- Ãrea de Entrada y Guardrail -->
            <div class="p-4 border-t bg-gray-50">
                <div class="flex items-center justify-between mb-2">
                    <div id="safety-status-indicator" class="p-2 rounded-full flex items-center space-x-2 transition-colors duration-300 bg-green-100">
                        <svg id="safety-icon" class="text-green-500" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.07-8.77"/><path d="M22 4L12 14.01l-3-3"/></svg>
                        <span id="safety-label" class="text-xs font-medium text-green-700">Seguro</span>
                    </div>
                    <span class="text-xs text-gray-500">Voz: Kore (Formal)</span>
                </div>
                
                <div class="flex space-x-3">
                    <input
                        type="text"
                        id="prompt-input"
                        class="flex-grow p-3 border border-indigo-300 rounded-full focus:ring-indigo-500 focus:border-indigo-500 shadow-inner disabled:bg-gray-100 transition-all"
                        placeholder="Escribe tu mensaje..."
                    />
                    <button
                        id="send-button"
                        class="p-3 rounded-full shadow-xl transition-all duration-300 flex items-center justify-center transform hover:scale-105 bg-indigo-600 hover:bg-indigo-700 text-white"
                        aria-label="Enviar mensaje"
                    >
                        <svg id="send-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 2L11 13M22 2L15 22L11 13L2 9L22 2Z"/></svg>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Script de LÃ³gica JavaScript Puro -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- CONFIGURACIÃ“N DE LAS APIS Y GLOBALES ---
            const GEMINI_TEXT_API_URL_BASE = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent';
            const GEMINI_TTS_API_URL_BASE = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent';
            const apiKey = ""; // La clave API serÃ¡ inyectada por el entorno de Canvas

            let chatHistory = [];
            let isLoading = false;
            
            // --- REFERENCIAS DOM ---
            const chatContainer = document.getElementById('chat-container');
            const promptInput = document.getElementById('prompt-input');
            const sendButton = document.getElementById('send-button');
            const audioPlayer = document.getElementById('audio-player');
            const safetyIndicator = document.getElementById('safety-status-indicator');
            const safetyIcon = document.getElementById('safety-icon');
            const safetyLabel = document.getElementById('safety-label');

            // --- FUNCIONES DE UTILIDAD DE AUDIO ---

            const base64ToArrayBuffer = (base64) => {
                const binaryString = atob(base64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            };

            const pcmToWav = (pcmData, sampleRate) => {
                const numChannels = 1;
                const bytesPerSample = 2; // 16-bit PCM
                const buffer = new ArrayBuffer(44 + pcmData.length * bytesPerSample);
                const view = new DataView(buffer);

                const writeString = (view, offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };

                writeString(view, 0, 'RIFF');
                view.setUint32(4, 36 + pcmData.length * bytesPerSample, true); 
                writeString(view, 8, 'WAVE');
                writeString(view, 12, 'fmt '); 
                view.setUint32(16, 16, true); 
                view.setUint16(20, 1, true); 
                view.setUint16(22, numChannels, true); 
                view.setUint32(24, sampleRate, true); 
                view.setUint32(28, sampleRate * numChannels * bytesPerSample, true); 
                view.setUint16(32, numChannels * bytesPerSample, true); 
                view.setUint16(34, 16, true); 
                writeString(view, 36, 'data'); 
                view.setUint32(40, pcmData.length * bytesPerSample, true); 

                let offset = 44;
                for (let i = 0; i < pcmData.length; i++) {
                    view.setInt16(offset, pcmData[i], true);
                    offset += bytesPerSample;
                }
                return new Blob([buffer], { type: 'audio/wav' });
            };

            const fetchWithRetry = async (url, options, maxRetries = 5) => {
                let lastError = null;
                for (let i = 0; i < maxRetries; i++) {
                    const delay = Math.pow(2, i) * 1000;
                    try {
                        const response = await fetch(url, options);
                        if (!response.ok) {
                            let errorDetail = response.statusText;
                            try {
                                const errorJson = await response.json();
                                errorDetail = errorJson.error ? errorJson.error.message : response.statusText;
                            } catch (e) { /* ignore */ }
                            throw new Error(`HTTP error! status: ${response.status}. Detail: ${errorDetail}`);
                        }
                        return response;
                    } catch (error) {
                        lastError = error;
                        if (i < maxRetries - 1) {
                            console.warn(`Intento fallido ${i + 1}/${maxRetries}. Reintentando en ${delay / 1000}s. Error: ${error.message}`);
                            await new Promise(resolve => setTimeout(resolve, delay));
                        }
                    }
                }
                throw new Error(`Fallo total al intentar conectar con la API. Ãšltimo error: ${lastError.message}`);
            };

            const generateAndPlayAudio = async (textToSpeak) => {
                const ttsPayload = {
                    contents: [{ parts: [{ text: textToSpeak }] }],
                    generationConfig: {
                        responseModalities: ["AUDIO"],
                        speechConfig: {
                            voiceConfig: {
                                prebuiltVoiceConfig: { voiceName: "Kore" }
                            }
                        }
                    },
                    model: "gemini-2.5-flash-preview-tts"
                };
                
                try {
                    const ttsResponse = await fetchWithRetry(`${GEMINI_TTS_API_URL_BASE}?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(ttsPayload)
                    });

                    const ttsResult = await ttsResponse.json();
                    const part = ttsResult?.candidates?.[0]?.content?.parts?.[0];
                    const audioData = part?.inlineData?.data;
                    const mimeType = part?.inlineData?.mimeType;

                    if (audioData && mimeType && mimeType.startsWith("audio/")) {
                        const rateMatch = mimeType.match(/rate=(\d+)/);
                        const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 24000;
                        
                        const pcmData = base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmData);
                        const wavBlob = pcmToWav(pcm16, sampleRate);
                        const audioUrl = URL.createObjectURL(wavBlob);

                        audioPlayer.src = audioUrl;
                        audioPlayer.play().catch(e => console.error("Error al reproducir audio:", e));
                    } else {
                        console.error("TTS: No se pudo obtener la data de audio.");
                    }
                } catch (error) {
                    console.error("Error en TTS:", error);
                    // AquÃ­ podrÃ­amos inyectar un mensaje de error visual si fuera necesario.
                }
            };
            
            // --- RENDERIZADO DEL CHAT ---

            const createMessageElement = (message) => {
                const isUser = message.role === 'user';
                const messageDiv = document.createElement('div');
                messageDiv.className = `flex ${isUser ? 'justify-end' : 'justify-start'}`;

                let bubbleClass;
                let roleText = isUser ? 'TÃº' : 'Agente de Voz';

                if (isUser) {
                    bubbleClass = message.status === 'blocked' 
                        ? 'bg-red-300 text-red-900 font-medium' 
                        : 'bg-indigo-600 text-white';
                } else {
                    bubbleClass = message.status === 'blocked_response' || message.status === 'error' 
                        ? 'bg-red-100 text-red-700 font-semibold border-2 border-red-400' 
                        : 'bg-gray-100 text-gray-800';
                }

                messageDiv.innerHTML = `
                    <div class="max-w-[85%] p-3 rounded-xl shadow-lg transition-all duration-300 ease-in-out ${bubbleClass}">
                        <span class="font-bold capitalize text-xs block mb-1 opacity-70">${roleText}</span>
                        <div>${message.text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')}</div>
                    </div>
                `;

                return messageDiv;
            };

            const renderChat = () => {
                // Borrar los mensajes previos (excepto el inicial de bienvenida, que se dejÃ³ en HTML)
                const messagesToClear = chatContainer.querySelectorAll('.flex');
                messagesToClear.forEach(msg => msg.remove());
                
                // Si el mensaje inicial fue borrado (lo cual no deberÃ­a ocurrir si se respeta el HTML original, 
                // pero si el usuario lo borra) lo reconstruimos
                if (chatContainer.children.length === 0) {
                    const welcomeDiv = document.createElement('div');
                    welcomeDiv.className = "text-center text-sm text-gray-500 p-2 bg-indigo-50 rounded-lg";
                    welcomeDiv.textContent = "ðŸ‘‹ Â¡Hola! Soy el Agente de Voz IA. Pregunta sobre seguridad, pero ten en cuenta mi Guardrail.";
                    chatContainer.appendChild(welcomeDiv);
                }


                // Renderizar los nuevos mensajes
                chatHistory.forEach(message => {
                    const messageElement = createMessageElement(message);
                    chatContainer.appendChild(messageElement);
                });
                
                // Indicador de carga
                if (isLoading) {
                    const loadingDiv = document.createElement('div');
                    loadingDiv.className = "flex justify-start";
                    loadingDiv.innerHTML = `
                        <div class="flex items-center bg-indigo-100 p-3 rounded-xl shadow-md text-indigo-600 animate-pulse">
                            <svg class="w-4 h-4 mr-2 animate-spin" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg>
                            Generando respuesta y voz...
                        </div>
                    `;
                    chatContainer.appendChild(loadingDiv);
                }

                // Scroll al final
                chatContainer.scrollTop = chatContainer.scrollHeight;
            };

            // --- LÃ“GICA DEL GUARDRAIL ---

            const checkSafety = (text) => {
                const lowerText = text.toLowerCase();
                let status = 'safe';
                
                // Guardrail simple: bloqueo
                if (lowerText.includes('violencia') || lowerText.includes('ilegal') || lowerText.includes('hacking') || lowerText.includes('exploit') || lowerText.includes('arma')) {
                    status = 'blocked';
                } else if (lowerText.includes('polÃ­tica') || lowerText.includes('finanzas') || lowerText.includes('salud')) {
                    // Guardrail simple: advertencia
                    status = 'warning';
                }

                updateSafetyUI(status);
                return status;
            };

            const updateSafetyUI = (status) => {
                let iconSVG, labelText, indicatorClass;

                switch (status) {
                    case 'safe':
                        iconSVG = '<path d="M22 11.08V12a10 10 0 1 1-5.07-8.77"/><path d="M22 4L12 14.01l-3-3"/>'; // CheckCircle
                        labelText = 'Seguro';
                        indicatorClass = 'bg-green-100 text-green-700';
                        break;
                    case 'warning':
                        iconSVG = '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/>'; // AlertTriangle
                        labelText = 'Advertencia';
                        indicatorClass = 'bg-yellow-100 text-yellow-700';
                        break;
                    case 'blocked':
                        iconSVG = '<circle cx="12" cy="12" r="10"/><line x1="15" y1="9" x2="9" y2="15"/><line x1="9" y1="9" x2="15" y2="15"/>'; // XCircle
                        labelText = 'Bloqueado';
                        indicatorClass = 'bg-red-100 text-red-700';
                        break;
                }
                
                // Actualizar clases y contenido del indicador
                safetyIndicator.className = `p-2 rounded-full flex items-center space-x-2 transition-colors duration-300 ${indicatorClass.split(' ')[0]}`;
                safetyLabel.textContent = labelText;
                safetyLabel.className = `text-xs font-medium ${indicatorClass.split(' ')[1]}`;
                
                // Recrear el SVG del icono
                safetyIcon.innerHTML = iconSVG;
                safetyIcon.className = `text-${indicatorClass.split(' ')[1].split('-')[1]}-500`;

                // Actualizar botÃ³n de envÃ­o
                const isBlocked = status === 'blocked';
                sendButton.disabled = isLoading || isBlocked;
                promptInput.disabled = isLoading;
                
                if (isBlocked) {
                    sendButton.className = sendButton.className.replace('bg-indigo-600 hover:bg-indigo-700 text-white', 'bg-gray-400 cursor-not-allowed');
                } else {
                    sendButton.className = sendButton.className.replace('bg-gray-400 cursor-not-allowed', 'bg-indigo-600 hover:bg-indigo-700 text-white');
                }
            };
            
            // --- LÃ“GICA PRINCIPAL DEL CHAT ---

            const handleSend = async () => {
                if (isLoading || sendButton.disabled) return;

                const userMessage = promptInput.value.trim();
                if (!userMessage) return;

                const safetyStatus = checkSafety(userMessage);

                // 1. AÃ±adir mensaje de usuario al historial
                chatHistory.push({ role: 'user', text: userMessage, status: safetyStatus === 'safe' ? 'sent' : 'blocked' });
                promptInput.value = '';
                renderChat();
                
                if (safetyStatus === 'blocked') {
                    const blockedMessage = "âŒ **Guardrail de Seguridad Activado:** Solicitud bloqueada. No se permite contenido que infrinja las polÃ­ticas Ã©ticas.";
                    chatHistory.push({ 
                        role: 'model',
                        text: blockedMessage,
                        status: 'blocked_response'
                    });
                    generateAndPlayAudio("Su solicitud ha sido bloqueada por el agente de seguridad.");
                    renderChat();
                    return;
                }

                // 2. Iniciar carga
                isLoading = true;
                sendButton.disabled = true;
                promptInput.disabled = true;
                renderChat(); // Muestra el indicador de carga

                try {
                    // 3. Prepara el historial para la API
                    const historyForApi = chatHistory
                        .filter(msg => msg.status === 'sent' || msg.status === 'received')
                        .map(msg => ({ 
                            role: msg.role === 'user' ? 'user' : 'model', 
                            parts: [{ text: msg.text }] 
                        }));

                    // Agrega el Ãºltimo mensaje del usuario
                    historyForApi.push({ role: 'user', parts: [{ text: userMessage }] });

                    const systemInstruction = "Eres un Agente de Voz de IA Seguro. Responde con un tono formal, profesional y conciso, priorizando la seguridad y la informaciÃ³n fidedigna. Limita tus respuestas a una o dos frases.";

                    const textPayload = {
                        contents: historyForApi,
                        systemInstruction: {
                            parts: [{ text: systemInstruction }]
                        },
                        tools: [{ "google_search": {} }], 
                    };

                    // 4. GeneraciÃ³n de Texto
                    const textResponse = await fetchWithRetry(`${GEMINI_TEXT_API_URL_BASE}?key=${apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(textPayload)
                    });

                    const result = await textResponse.json();
                    const generatedText = result.candidates?.[0]?.content?.parts?.[0]?.text || "El agente no pudo generar una respuesta clara.";

                    // 5. AÃ±adir la respuesta de la IA al historial y reproducir voz
                    chatHistory.push({ role: 'model', text: generatedText, status: 'received' });
                    generateAndPlayAudio(generatedText);

                } catch (error) {
                    console.error("Error en el chat:", error);
                    const errorMessage = `âš ï¸ Error de conexiÃ³n: ${error.message}.`;
                    chatHistory.push({ role: 'model', text: errorMessage, status: 'error' });
                    generateAndPlayAudio("Ha ocurrido un error al conectar con el agente de inteligencia artificial.");
                } finally {
                    // 6. Finalizar carga
                    isLoading = false;
                    sendButton.disabled = checkSafety(promptInput.value) === 'blocked';
                    promptInput.disabled = false;
                    renderChat();
                }
            };
            
            // --- EVENT LISTENERS ---
            sendButton.addEventListener('click', handleSend);
            promptInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    handleSend();
                }
            });
            promptInput.addEventListener('input', (e) => checkSafety(e.target.value));

            // ComprobaciÃ³n inicial
            updateSafetyUI('safe');
        });
    </script>
</body>
</html>